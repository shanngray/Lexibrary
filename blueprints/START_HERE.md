# Lexibrarian — Start Here

> **Note:** `blueprints/` is a hand-maintained pseudo-lexibrary for agents building Lexibrarian itself — not to be confused with the `.lexibrary/` output that Lexibrarian produces for other projects.

## Project Topology

```
src/lexibrarian/
├── __init__.py
├── __main__.py
├── cli/                         ← CLI package — two Typer apps + shared helpers
│   ├── __init__.py              ← Re-exports lexi_app and lexictl_app
│   ├── _shared.py               ← Shared helpers: console, require_project_root(), stub()
│   ├── lexi_app.py              ← Agent-facing CLI (lexi): lookup, index, describe, concepts, concept, stack, search
│   └── lexictl_app.py           ← Maintenance CLI (lexictl): init, update (--changed-only), validate, status, setup (--update, --hooks), sweep (--watch), daemon (start/stop/status)
├── exceptions.py                ← LexibraryNotFoundError
├── search.py                    ← unified_search() — cross-artifact search (concepts, design files, Stack posts)
├── archivist/                   ← LLM pipeline for design file + START_HERE generation (Phase 4)
│   ├── __init__.py              ← Public API re-exports
│   ├── change_checker.py        ← ChangeLevel enum + check_change() — classify source vs design file drift
│   ├── dependency_extractor.py  ← Tree-sitter import resolution to project-relative paths
│   ├── pipeline.py              ← update_file() + update_project() — full generation pipeline
│   ├── service.py               ← ArchivistService — async BAML calls with provider routing
│   └── start_here.py            ← generate_start_here() — project-level START_HERE.md generation
├── artifacts/                   ← Pydantic 2 models + parser/serializer/writer for all artifact types
│   ├── __init__.py
│   ├── aindex.py                ← AIndexFile + AIndexEntry models
│   ├── aindex_parser.py         ← Parse .aindex files from disk
│   ├── aindex_serializer.py     ← Serialize AIndexFile to .aindex text
│   ├── concept.py               ← ConceptFile + ConceptFileFrontmatter models
│   ├── design_file.py           ← DesignFile + DesignFileFrontmatter + StalenessMetadata models
│   ├── design_file_parser.py    ← Parse design files from disk (full, metadata-only, frontmatter-only)
│   ├── design_file_serializer.py ← Serialize DesignFile to YAML frontmatter + markdown + footer
│   └── writer.py                ← write_artifact() — persists any artifact to disk
├── ast_parser/                  ← Tree-sitter interface extraction: models, registry, language parsers, canonical renderer
│   ├── __init__.py              ← Public API: parse_interface(), hash_interface(), compute_hashes()
│   ├── models.py                ← Pydantic 2 models: InterfaceSkeleton, ClassSig, FunctionSig, ConstantSig, ParameterSig
│   ├── registry.py              ← GrammarInfo + GRAMMAR_MAP; lazy-load/cache tree-sitter Language + Parser
│   ├── skeleton_render.py       ← render_skeleton() — deterministic canonical text for hashing
│   ├── python_parser.py         ← extract_interface() for .py / .pyi
│   ├── typescript_parser.py     ← extract_interface() for .ts / .tsx
│   └── javascript_parser.py     ← extract_interface() for .js / .jsx
├── baml_client/                 ← AUTO-GENERATED by BAML — do not edit; contents omitted from this tree
├── config/                      ← Config schema (Pydantic 2) + loader + defaults
│   ├── __init__.py
│   ├── defaults.py              ← Default config template written on lexictl init
│   ├── loader.py                ← Two-tier YAML loader (project + user overrides)
│   └── schema.py                ← LexibraryConfig Pydantic model
├── crawler/                     ← Bottom-up crawl orchestration + change detection (LLM-based, partially broken)
│   ├── __init__.py
│   ├── change_detector.py       ← SHA-256 + LLM-based change detection
│   ├── discovery.py             ← Filesystem traversal + file enumeration
│   ├── engine.py                ← full_crawl() orchestrator (partially broken — see blueprints)
│   └── file_reader.py           ← Read source files for crawl input
├── daemon/                      ← Sweep + periodic watch + deprecated watchdog
│   ├── __init__.py
│   ├── debouncer.py             ← Coalesce rapid file-change events
│   ├── logging.py               ← setup_daemon_logging() — RotatingFileHandler to .lexibrarian.log
│   ├── scheduler.py             ← Periodic sweep scheduler
│   ├── service.py               ← DaemonService — run_once, run_watch, run_watchdog entry points
│   └── watcher.py               ← watchdog filesystem event handler
├── hooks/                       ← Git hook installation for automatic updates
│   ├── __init__.py
│   └── post_commit.py           ← install_post_commit_hook() — git post-commit hook for lexictl update
├── ignore/                      ← pathspec-based ignore pattern matching
│   ├── __init__.py
│   ├── gitignore.py             ← Load + parse .gitignore files
│   ├── matcher.py               ← IgnoreMatcher combining .gitignore + config + .lexignore patterns
│   └── patterns.py              ← Built-in default ignore patterns
├── iwh/                         ← IWH (I Was Here) ephemeral inter-agent signal files
│   ├── __init__.py              ← Public API re-exports
│   ├── model.py                 ← IWHFile Pydantic 2 model, IWHScope type alias
│   ├── parser.py                ← parse_iwh() — YAML frontmatter + markdown → IWHFile
│   ├── serializer.py            ← serialize_iwh() — IWHFile → markdown string
│   ├── reader.py                ← read_iwh(), consume_iwh() (consume deletes even corrupt files)
│   ├── writer.py                ← write_iwh() — create IWH file with auto directory creation
│   └── gitignore.py             ← ensure_iwh_gitignored() — idempotent .gitignore integration
├── indexer/                     ← Structural .aindex generation (no LLM): generator + orchestrator
│   ├── __init__.py
│   ├── generator.py             ← generate_aindex() — builds AIndexFile from a directory
│   └── orchestrator.py          ← lexi index entry point; drives generator → serializer → writer
├── init/                        ← lexictl init scaffolding (.lexibrary/ skeleton) + project detection + wizard + agent rule generation
│   ├── __init__.py
│   ├── detection.py             ← Pure detection functions: project name, scope roots, agent envs, LLM providers, project type
│   ├── scaffolder.py            ← create_lexibrary_skeleton(), create_lexibrary_from_wizard()
│   ├── wizard.py                ← run_wizard() — 8-step interactive init flow; WizardAnswers dataclass
│   └── rules/                   ← Agent environment rule generation (claude, cursor, codex)
│       ├── __init__.py          ← generate_rules(), supported_environments()
│       ├── markers.py           ← Marker-based section detection/replacement for shared files
│       ├── base.py              ← Shared rule content: get_core_rules(), orient/search skills
│       ├── claude.py            ← generate_claude_rules() — CLAUDE.md + .claude/commands/
│       ├── cursor.py            ← generate_cursor_rules() — .cursor/rules/ + .cursor/skills/
│       └── codex.py             ← generate_codex_rules() — AGENTS.md
├── llm/                         ← BAML client wrapper + rate limiter + factory
│   ├── __init__.py
│   ├── factory.py               ← create_llm_service() factory
│   ├── rate_limiter.py          ← Token-bucket rate limiter
│   └── service.py               ← LLMService wrapping BAML async client
├── stack/                       ← Stack Overflow-style Q&A knowledge base (Phase 6)
│   ├── __init__.py              ← Public API re-exports
│   ├── models.py                ← StackPost, StackPostFrontmatter, StackAnswer, StackPostRefs models
│   ├── index.py                 ← StackIndex — in-memory search/filter of Stack posts
│   ├── mutations.py             ← add_answer(), record_vote(), accept_answer(), mark_duplicate(), mark_outdated()
│   ├── parser.py                ← parse_stack_post() — YAML frontmatter + markdown → StackPost
│   ├── serializer.py            ← serialize_stack_post() — StackPost → markdown string
│   └── template.py              ← render_post_template() — scaffold new Stack post files
├── tokenizer/                   ← Pluggable token counting backends
│   ├── __init__.py
│   ├── anthropic_counter.py     ← Anthropic token counting backend
│   ├── approximate.py           ← Character-ratio approximate backend
│   ├── base.py                  ← TokenCounter protocol
│   ├── factory.py               ← Backend selection factory
│   └── tiktoken_counter.py      ← tiktoken (OpenAI) backend
├── utils/                       ← Hashing, language detection, logging, paths, root, atomic writes, conflict detection, locks
│   ├── __init__.py
│   ├── atomic.py                ← atomic_write() — temp-file + os.replace() for safe writes
│   ├── conflict.py              ← has_conflict_markers() — git merge conflict detection
│   ├── hashing.py               ← hash_file() SHA-256 helper
│   ├── languages.py             ← detect_language() by extension
│   ├── locks.py                 ← DirectoryLockManager — per-directory threading.Lock instances
│   ├── logging.py               ← setup_logging() rich handler
│   ├── paths.py                 ← Path helpers for .lexibrary/ layout
│   └── root.py                  ← find_project_root() — walks up to locate .lexibrary/
├── validator/                   ← Library health checks and validation reporting (Phase 7)
│   ├── __init__.py              ← Public API: validate_library(), AVAILABLE_CHECKS; check registry
│   ├── checks.py                ← Individual check functions (error/warning/info severity)
│   └── report.py                ← ValidationIssue, ValidationSummary, ValidationReport models
└── wiki/                        ← Concept file parser, serializer, template, resolver, and index (Phase 5)
    ├── __init__.py              ← Public API re-exports
    ├── index.py                 ← ConceptIndex — in-memory search/retrieval of concept files
    ├── parser.py                ← parse_concept_file() — markdown + YAML frontmatter → ConceptFile
    ├── resolver.py              ← WikilinkResolver — resolve [[wikilinks]] to concepts or Stack posts
    ├── serializer.py            ← serialize_concept_file() — ConceptFile → markdown string
    └── template.py              ← render_concept_template(), concept_file_path() — scaffolding helpers
```

## Package Map

| Package | Role |
| --- | --- |
| `cli` | Two Typer CLI apps: `lexi_app` (agent-facing: lookup, index, describe, concepts, concept, stack, search) and `lexictl_app` (maintenance: init, update, validate, status, setup, sweep, daemon); shared helpers in `_shared.py` (`console`, `require_project_root`, `stub`) |
| `archivist` | LLM pipeline for design file + START_HERE generation: `ArchivistService`, `update_file`, `update_files`, `update_project`, `generate_start_here`, `check_change`, `extract_dependencies`; safety features: conflict marker check, design hash TOCTOU re-check, atomic writes |
| `artifacts` | Pydantic 2 models: `DesignFile`, `AIndexFile`, `ConceptFile`; plus parsers, serializers, writer |
| `ast_parser` | Tree-sitter interface extraction: `parse_interface`, `compute_hashes`, `hash_interface`; `InterfaceSkeleton` model; Python / TypeScript / JavaScript parsers; `render_skeleton` canonical renderer |
| `config` | `LexibraryConfig` schema (incl. `scope_root`, `ASTConfig`), two-tier YAML loader, default config template |
| `crawler` | `full_crawl()` orchestrator; discovery, file reading, change detection (LLM-based; partially broken -- see crawler/engine.md) |
| `daemon` | `DaemonService` -- three entry points: `run_once` (single sweep), `run_watch` (periodic), `run_watchdog` (deprecated); `setup_daemon_logging` for rotating file logging |
| `ignore` | `IgnoreMatcher` combining `.gitignore` + config + `.lexignore` patterns via pathspec |
| `indexer` | Structural `.aindex` pipeline: `generate_aindex` (with design file frontmatter lookup) -> `serialize_aindex` -> `write_artifact`; no LLM |
| `init` | `create_lexibrary_skeleton()`, `create_lexibrary_from_wizard()` -- creates `.lexibrary/` + `.lexignore` on `lexictl init`; ensures `.lexibrarian.log` and `.lexibrarian.pid` are gitignored; `detection.py` auto-discovers project name, scope roots, agent envs, LLM providers, project type; `wizard.py` runs 8-step interactive setup via `run_wizard()` → `WizardAnswers`; `rules/` subpackage generates agent environment files (Claude, Cursor, Codex) via `generate_rules()` |
| `iwh` | IWH (I Was Here) ephemeral inter-agent signal files: `IWHFile` model, `parse_iwh`, `serialize_iwh`, `read_iwh`, `consume_iwh`, `write_iwh`; `ensure_iwh_gitignored()` for `.gitignore` integration |
| `llm` | `LLMService` wrapping BAML client; `RateLimiter`; `create_llm_service()` factory |
| `stack` | Stack Q&A knowledge base: `StackPost`, `StackIndex`, `parse_stack_post`, `serialize_stack_post`, `render_post_template`; mutations: `add_answer`, `record_vote`, `accept_answer`, `mark_duplicate`, `mark_outdated` |
| `tokenizer` | `TokenCounter` protocol; tiktoken / anthropic / approximate backends |
| `hooks` | Git hook installation: `install_post_commit_hook` for automatic `lexictl update --changed-only` after commits |
| `utils` | `hash_file`, `detect_language`, `setup_logging`, `find_project_root`, path helpers, `atomic_write` (safe file writes), `has_conflict_markers` (git conflict detection), `DirectoryLockManager` (per-directory locks) |
| `validator` | `validate_library()` orchestrator; `AVAILABLE_CHECKS` registry; `ValidationReport`, `ValidationIssue`, `ValidationSummary` models; 10 individual checks grouped by severity (error: wikilink_resolution, file_existence, concept_frontmatter; warning: hash_freshness, token_budgets, orphan_concepts, deprecated_concept_usage; info: forward_dependencies, stack_staleness, aindex_coverage) |
| `wiki` | `ConceptIndex` (search/retrieval by title, alias, tag, substring); `parse_concept_file`; `serialize_concept_file`; `WikilinkResolver` (`ResolvedLink`, `UnresolvedLink`); `render_concept_template`, `concept_file_path` |
| `search` | `unified_search()` — cross-artifact search across concepts, design files, and Stack posts; `SearchResults` with Rich rendering |

## Navigation by Intent

| Task | Read first |
| --- | --- |
| Add / modify an agent-facing CLI command | `blueprints/src/lexibrarian/cli/lexi_app.md` |
| Add / modify a maintenance CLI command | `blueprints/src/lexibrarian/cli/lexictl_app.md` |
| Modify shared CLI helpers | `blueprints/src/lexibrarian/cli/_shared.md` |
| Modify design file generation pipeline | `blueprints/src/lexibrarian/archivist/pipeline.md` |
| Change archivist LLM service or provider routing | `blueprints/src/lexibrarian/archivist/service.md` |
| Change change detection logic | `blueprints/src/lexibrarian/archivist/change_checker.md` |
| Modify START_HERE generation | `blueprints/src/lexibrarian/archivist/start_here.md` |
| Add a language parser or modify AST extraction | `blueprints/src/lexibrarian/ast_parser/` |
| Change config keys or defaults | `blueprints/src/lexibrarian/config/` |
| Modify crawl logic (LLM-based) | `blueprints/src/lexibrarian/crawler/engine.md` |
| Modify structural indexing (no LLM) | `blueprints/src/lexibrarian/indexer/` |
| Change ignore patterns or .lexignore | `blueprints/src/lexibrarian/ignore/` |
| Add / modify LLM prompts | `baml_src/` (source-of-truth for prompts) |
| Change artifact data models | `blueprints/src/lexibrarian/artifacts/` |
| Change `.aindex` file format | `blueprints/src/lexibrarian/artifacts/aindex_serializer.md` + `aindex_parser.md` |
| Change design file format | `blueprints/src/lexibrarian/artifacts/design_file_serializer.md` + `design_file_parser.md` |
| Modify daemon behavior | `blueprints/src/lexibrarian/daemon/service.md` |
| Modify daemon logging | `blueprints/src/lexibrarian/daemon/logging.md` |
| Install or modify git hooks | `blueprints/src/lexibrarian/hooks/post_commit.md` |
| Modify atomic file writes | `blueprints/src/lexibrarian/utils/atomic.md` |
| Modify conflict marker detection | `blueprints/src/lexibrarian/utils/conflict.md` |
| Modify directory locking | `blueprints/src/lexibrarian/utils/locks.md` |
| Add a tokenizer backend | `blueprints/src/lexibrarian/tokenizer/` |
| Change `lexictl init` scaffolding | `blueprints/src/lexibrarian/init/scaffolder.md` |
| Modify project auto-detection | `blueprints/src/lexibrarian/init/detection.md` |
| Modify the init wizard flow | `blueprints/src/lexibrarian/init/wizard.md` |
| Add / modify agent environment rules | `blueprints/src/lexibrarian/init/rules/` |
| Add / modify IWH signal files | `blueprints/src/lexibrarian/iwh/` |
| Change path utilities | `blueprints/src/lexibrarian/utils/paths.md` |
| Raise / handle project-not-found | `blueprints/src/lexibrarian/exceptions.md` |
| Add / modify concept wiki utilities | `blueprints/src/lexibrarian/wiki/` |
| Add / modify Stack Q&A features | `blueprints/src/lexibrarian/stack/` |
| Change cross-artifact search | `blueprints/src/lexibrarian/search.md` |
| Add / modify validation checks | `blueprints/src/lexibrarian/validator/checks.md` |
| Change validation report models | `blueprints/src/lexibrarian/validator/report.md` |
| Change validation orchestrator | `blueprints/src/lexibrarian/validator/__init__.md` |

## Key Constraints

- `from __future__ import annotations` in **every** module
- pathspec pattern name is `"gitignore"` — NOT `"gitwildmatch"`
- Config: YAML via PyYAML, validated with Pydantic 2
- Output: `rich.console.Console` — no bare `print()`
- `baml_client/` is auto-generated — never edit it directly
- `crawler/engine.py` is partially broken: references `config.output`, `FileEntry`/`DirEntry`/`IandexData` types not yet defined — use `indexer/orchestrator.py` for `lexi index` instead

## Navigation Protocol

Before editing a file, read its design file in `blueprints/src/`. Keep design files updated when you change source files — the source is truth, the design file is the explanation.
